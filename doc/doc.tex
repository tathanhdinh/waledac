\documentclass[11pt]{article}

\setlength{\topmargin}{-.20in}
\setlength{\textheight}{9in}
\setlength{\oddsidemargin}{.125in}
\setlength{\textwidth}{6.25in}

\usepackage[frenchb]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{moreverb}
\usepackage{listings} 
\usepackage{url}
\usepackage{colortbl}
\usepackage{bigdelim}
\usepackage{bigstrut}
\usepackage{multirow}
\usepackage{array}
\usepackage{float}
\usepackage{color}
\usepackage{verbatim}
%%%% Liens et coloration des liens %%%% 

\usepackage{hyperref} 
\hypersetup{unicode=false,pdftoolbar=true,pdfmenubar=true,pdffitwindow=false,colorlinks=true,linkcolor=black,citecolor=black,filecolor=magenta,urlcolor=gray}

%%%% Packages LatexPix %%%% 

\usepackage{bez123}
\usepackage{calc}
\usepackage{curves}
\usepackage{ebezier}
\usepackage{eepic}
\usepackage{multiply}
\usepackage{pgf} 
\usepackage{rotating}
\usepackage{xcolor} 

%%%% Maths %%%%

\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsmath}

\newcommand{\M}{\mathcal M}
\newcommand{\F}{\mathbb F}
\newcommand{\Z}{\mathbb Z}
\newcommand{\N}{\mathbb N}
\newcommand{\Q}{\mathbb Q}
\newcommand{\W}{\mathcal W}


% options pour le package listings
\lstset{language=C,frame=shadowbox,showstringspaces=false,stringstyle=\ttfamily}


\setcounter{page}{1}
\begin{document}
\title{Simulateur de Botnet}
\date{} 

\newcommand{\sautligneperso}{\newline\vspace{1mm}\newline}
\newcommand{\esp}[1]{\hspace*{#1mm}}

\maketitle
\section{Compilation}
Deux versions du simulateur ont été programmées en C++, une qui utilise un thread pour chaque bot du botnet et l'autre sans. Dans le premier cas cela permet le calcul en parallèle, rendant la simulation plus proche de la réalité, chaque bot fonctionnant de manière indépendante, dans le deuxième cas, les actions des bots sont effectuées séquentiellement, le ou les actions du bot numéroté 3 sont effectuées après le ou les actions du bot 2, ce qui est moins réaliste.\\\\ Cette deuxième version est utile lorsque l'on souhaite lancer la simulation sur un seul processeur, puisqu'elle nécessite moins de ressources (on économise le changement de contexte effectué par l'OS lorsqu'il bascule d'un thread à l'autre). Dans le CMakeFile.txt on ajoutera ou pas la macro THREAD\_VERSION dans les options de gcc en fonction de la version du simulateur que l'on souhaite compiler.  
\begin{center}
\begin{verbatim}
set (CMAKE_CXX_FLAGS "-Wall -W -Wno-deprecated -D THREAD_VERSION")
\end{verbatim}
\end{center}
La compilation du programme nécessite les librairies Boost, QT et VTK (avec support Qt). 
\newpage
\section{Classe Bot}
Tout les bots du Botnet (spammers, repeaters, attackers, protecters, c\&c dans le cas de Waledac) dérivent de cette classe.\\

\begin{minipage}[c]{.46\linewidth}
\begin{verbatim} 
class Bot : public 
boost::enable_shared_from_this< Bot >
{

private :
	std::string m_id;
	bot_status m_status;

public :
	Bot();
	const std::string& id() const;
	
	virtual bot_status& status();
	bool is_compromised();
	
	virtual response_code 
	send_message(message_code message);
	
	virtual void init(bot_t& server, 
	bots_t& plist, bots_t& rlist) = 0;
	
	#ifdef THREAD_VERSION
	virtual void execute() = 0;
	virtual void start() = 0;
	virtual void wait() = 0;
	#endif
	
};
\end{verbatim}	
\end{minipage} \hfill
\begin{minipage}[c]{.46\linewidth}
Chaque bot à un identifiant (m\_id) et un statut (m\_status) accessibles respectivement par le biais des fonctions id() et status(). La fonction is\_compromised() permet de savoir si un bot est entre les mains de l'attaquant. Le bot est dit compromis par l'attaquant si et seulement si le statut du bot vaut COMPROMISED et à ce moment le fonctionnement du Bot est stoppé (il ne peut pas repasser à l'ennemi).\\\\Chaque Bot peut effectuer des "actions", comme par exemple l'envoi d'un message à un autre bot (par le biais de la fonction send\_message()).
\end{minipage}

\newpage
\section{Classe Spammer}
Cette classe implémente les fonctionnalitées d'un Bot de type spammer.\\

\begin{minipage}[c]{.46\linewidth}
\begin{verbatim} 
class Spammer : public Bot
{
private:
	bots_t m_rlist;
	void update_status(response_code code);
	#ifdef THREAD_VERSION
	boost::shared_ptr< boost::thread > 
	m_spammer_thread;
	#endif
	
public:
	Spammer();
	void update_rlist();
	
	bots_t rlist();
	
	virtual response_code 
	send_message(message_code message);
	
	virtual void init(bot_t& server, 
	bots_t& plist, bots_t& rlist);
	
	#ifdef THREAD_VERSION
	virtual void execute();
	virtual void start();
	virtual void wait();
	#endif

};
\end{verbatim}	
\end{minipage} \hfill
\begin{minipage}[c]{.46\linewidth}
Chaque spammer a une rlist (m\_rlist) accessible par le biais de la fonction rlist() et qui est mise à jour grâce à la fonction update\_rlist(). Cette RList a une taille égale au nombre de répéteurs + nombre d'attaquants dans le botnet divisé par 3.
Dans un botnet de type waledac c'est le spammer qui se connecte au répéteur, dans notre cas cette action est effectuée en appellant la fonction 
send\_message(MESSAGE\_TASKREQ) (le spammer demande une tache au répéteur).\\\\Le répéteur est choisi aléatoirement dans la RList du spammer, il peut ne pas répondre (nous avons donc 
simulé "l'echec de connection", 1 chance sur 10 que cela arrive), si tout se passe bien le répéteur va choisir aléatoirement un sous-ensemble de sa RList et va l'envoyer au spammer, 
cette sous-liste est de taille égale à la taille d'une RList divisé par 5.\\\\Le spammer qui recoit cette sous-liste va mettre à jour sa RList de la 
manière suivante : il va creer une liste de répéteurs en concaténant la liste que lui envoie le répéteur avec sa RList actuelle, puis il 
va effectuer une permutation aléatoire de cette liste et choisir un interval dans celle-ci de longueur égal à la taille d'une RList, les bots dans 
cet interval sont la nouvelle RList.\\\\
\end{minipage}

\newpage
\section{Classe Repeater}
Cette classe implémente les fonctionnalitées d'un Bot de type Repeater.\\

\begin{minipage}[c]{.46\linewidth}
\begin{verbatim} 
class Repeater : public Bot
{
private:
	bots_t m_rlist;
	bots_t m_plist;
	#ifdef THREAD_VERSION
	boost::shared_ptr<boost::thread> 
	m_repeater_thread;
	#endif

public:
	Repeater();
	virtual void update_rlist();
	virtual void update_plist();
	
	virtual bots_t sub_rlist();
	virtual bots_t sub_plist();
	
	bots_t plist();
	bots_t rlist();
	
	virtual response_code 
	send_message(message_code message);
	
	virtual void init(bot_t& server, 
	bots_t& plist, bots_t& rlist);
	
	#ifdef THREAD_VERSION
	virtual void execute();
	virtual void start();
	virtual void wait();
	#endif
};
\end{verbatim}	
\end{minipage} \hfill
\begin{minipage}[c]{.46\linewidth}
Le répéteur met à jour sa RList et sa PList de la même manière que précédemment en contactant un autre répéteur aléatoirement dans sa RList.
\end{minipage}


\newpage
\section{Classe Attacker}
Cette classe implémente les fonctionnalitées d'un Bot de type attaquant. Elle dérive de la class Repeater (la plupart des attaques sur le botnet 
waledac se font en introduisant des repeaters). On a implémenté l'attaque suivante : chaque spammer qui se connecte à un de nos attaquants est compromis (on suppose que notre attaquant peut prendre complétement le contrôle du spammer : lui faire télécharger une nouvelle RList, le détruire ...).\\\\ 

\begin{minipage}[c]{.46\linewidth}
\begin{verbatim} 
class Attacker : public Repeater
{
private:
	#ifdef THREAD_VERSION
	boost::shared_ptr< boost::thread > 
	m_attacker_thread;
	#endif

public:
	Attacker();
	virtual void update_rlist();
	virtual void update_plist();
	virtual bots_t sub_rlist();
	virtual bots_t sub_plist();
	
	virtual response_code 
	send_message(message_code message);
	
	#ifdef THREAD_VERSION
	virtual void execute();
	virtual void start();
	virtual void wait();
	#endif
};
\end{verbatim}	
\end{minipage} \hfill
\begin{minipage}[c]{.46\linewidth}
Dans notre implémentation, l'attaquant envoie un message de type RESPONSE\_STOP (par le biais de la fonction send\_message()) au spammer qui l'a contacté, peu importe ce qu'il a reçu comme requête, ce message signifie que le Spammer passe entre les mains de l'attaquant. Si on souhaite implémenter une attaque différente on changera la fonction send\_message().\\L'attaquant met à jour sa RList et sa PList de la même manière que le répéteur. 
\end{minipage}

\newpage
\section{Classe Protecter}
Cette classe implémente les fonctionnalitées d'un Bot de type Protecteur.\\

\begin{minipage}[c]{.46\linewidth}
\begin{verbatim} 
class Protecter : public Bot
{	
	private:
		#ifdef THREAD_VERSION
		boost::shared_ptr<boost::thread> 
		m_protecter_thread;
		#endif
		
	public:
		Protecter();
		bot_t server;
	
		virtual response_code 
		send_message(message_code message);
		virtual void init(bot_t& server, 
		bots_t& plist, bots_t& rlist);
		
		#ifdef THREAD_VERSION
		virtual void execute();
		virtual void start();
		virtual void wait();
		#endif
};
\end{verbatim}	
\end{minipage} \hfill
\begin{minipage}[c]{.46\linewidth}
Tout les protecteurs sont connectés au Server, les protecteurs n'ont pas de RList ou de Plist, dans notre implémentation le répéteur transmet les ordres du serveur ou à destination du serveur.
\end{minipage}

\newpage
\section{Classe ServerCC}
Cette classe implémente les fonctionnalitées d'un Bot de type ServerCC.\\

\begin{minipage}[c]{.46\linewidth}
\begin{verbatim} 
class ServerCC : public Bot
{
private:
	#ifdef THREAD_VERSION
	boost::shared_ptr<boost::thread> 
	m_servercc_thread;
	#endif	 

public:
	ServerCC();
	
	response_code 
	process_message(message_code message);
	virtual response_code 
	send_message(message_code message);
	
	virtual void init(bot_t& server, 
	bots_t& plist, bots_t& rlist);

	#ifdef THREAD_VERSION
	virtual void execute();
	virtual void start();
	virtual void wait();
	#endif

};
\end{verbatim}	
\end{minipage} \hfill
\begin{minipage}[c]{.46\linewidth}
Le serveur reçoit des messages des protecteurs par le biais de la fonction process\_message() et leur répond. Le serveur ne prend jamais l'initiative de la communication.
\end{minipage}
\newpage

\section{Routage de messages}
\begin{figure}[h!]
  \centering
    \includegraphics[width=0.85\textwidth]{send_message_cut}
  \caption{Routage de messages}
\end{figure}

\newpage

% \begin{center}
% \includegraphics[width=0.75\textwidth]{send_message_cut.png} 
% \end{center}

\section{Classe Botnet}
Cette classe implémente les fonctionnalitées du Botnet.\\

\begin{minipage}[c]{.46\linewidth}
\begin{verbatim} 
class Botnet : 
public boost::enable_shared_from_this< Botnet >
{
public:
	Botnet(unsigned int repeaters_number, 
	unsigned int protecters_number, 
	unsigned int spammers_number, 
	unsigned int attackers_number);
		   
	void init();
	void start();
	
	#ifdef THREAD_VERSION
	void wait();
	#endif
	
	bots_t repeaters_list();
	bots_t protecters_list();
	bots_t spammers_list();
	bots_t attackers_list();
	bot_t server();
	
	
private:	
	bots_t repeaters;
	bots_t protecters;
	bots_t spammers;
	bots_t attackers;
	bot_t server_cc;
};
\end{verbatim}	
\end{minipage} \hfill
\begin{minipage}[c]{.46\linewidth}
On crée un botnet via le constructeur, qui prend en paramètre un nombre de répéteurs, protecteurs, spammers, attaquants, il n'y a qu'un seul command and control.\\\\On a accès à la liste des bots (bots\_t repeaters, bots\_t protecters, bots\_t spammers, bots\_t attackers, bot\_t server\_cc) via les fonctions repeaters\_list(),protecters\_list(), spammers\_list(), attackers\_list(), server().
\end{minipage}
\newpage


\section{Exemple}
Si on lance le simulateur avec 50 répéteurs, 50 spammers, 50 protecteurs, 10 attaquants et 1 serveur :
\begin{itemize}
 \item La RList des spammers et des répéteurs et des attaquants est de taille 60/3.
 \item Initialement la RList est choisi aléatoirement parmis les 50 répéteurs + 10 attaquants pour chaque spammer, répéteur, attaquant.
 \item Même chose pour la Plist des répéteurs.
 \item Un spammer effectue une action toute les 2 secondes (cela peut être modifié).
 \item La seule action possible du Spammer est de contacter un répéteur/attaquant.
 \item Chaque spammer contacte un attaquant avec une probabilitée 10/50
 \item La connection echoue avec une probabilitée 1/10
 \item Le spammer recevra une liste de répéteurs de taille 60/(5*3) de la part du répéteur qu'il contacte.
 \item Le spammer mettra à jour sa RList avec la liste précédente.
\end{itemize}
\newpage

\section{Visualisation}
Le graphe du Botnet dérive de la classe vtkMutableDirectedGraph (il s'agit d'un graphe dirigé et modifiable). Dans la version avec threads, le rafraichissement du rendu graphique est effectué toutes les 300 millisecondes (par défaut), les bots peuvent avoir effectué plus d'une action chacun (réception, envoie d'un message par exemple), dans la version sans threads ce n'est que lors des rafraichissements du rendu graphique que les bots "vivent".
\end{document} 














